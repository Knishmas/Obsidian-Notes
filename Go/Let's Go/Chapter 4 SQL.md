
# 4.1 Setting Up SQL 
 ```sql 
CREATE DATABASE snippetbox CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci
 ```
 - **COLLATE:** Defines string comparison and how data is sorted within the database. 
 - **utf8mb4:** UTF-8 standard character encoding that includes almost all characters from all writing systems .
 - **Unicode:** Unicode standard
 - **ci:** Stands for 'case insensitive'. It will treat lower and upper cases as the same within the database. 

# 4.3 Modules & reproducible builds 
- **go.sum:** This file contains cryptographic checksums representing the content of the required packages. Similiar to package.json in node.js 
	**Serves two useful functions** 
	1. ```go mod verify``` verifies the checksum of the packages on your machine to make sure they're right. 
	2. ```go mod download``` downloads all the dependencies within the project. 

# 4.4 Creating a database connection pool

## Connecting web app to database
```sql.Open()```
- Function that initializes a new sql.DB object and returns a pool of DB connections. 
- Doesn't create any connections, just initializes pool for future use. 
- ```db.Ping()``` method that checks if the db is reachable, makes a connection. 
```db, err := sql.Open("mysql", "web:pass@/snippetbox?parseTime=true")```
- 1st parameter - Driver name. *Find name through the DB's docs*
- 2nd parameter -  Data source name (DSN) or connection string. Describes how to connect to your DB.
	- Format of DSN will depend on your driver. *Refer to docs*
```parseTime=true```
- Driver specific - converts sql time/date to go time.time. obj. 

# 4.6 Executing SQL Statements 
- Go has 3 methods for executing SQL statements: 
	1. ``DB.Query()``-  SELECT queries which return *multiple row.*  
	2. ``DB.QueryRow()``- SELECT queries which return a *single row*.  
	3.  ``DB.Exec()`` - Used for statements which don’t return rows (like INSERT and DELETE).
		- Returns a sql.Result type, which contains some basic  information about what happened when the statement was executed.

- **sql.Result type** - Has 2 relevant methods 
	1. `lastInsertID()` - returns integer (int64) generated by the database in response to the command. Usually from an auto-increment column. 
	2. `RowsAffected()` - returns the number of rows (int64) affected by the statement. 
- *Side Note:* We use placeholders such as `?` with the data we want to insert (rather than string interpolation) because we want to avoid SQL injection attacks. 

# 4.7 Single-record SQL queries
- `Scan()` :  the `Scan` function is used to copy the columns from the current row into the values pointed at by dest. 
	- If the query returns no rows, then row.Scan() will return a sql.ErrNoRows error.
	- The drive will automatically convert SQL raw output to native go types. 
		- *Example*: *`CHAR`, `VARCHAR` and `TEXT` map to `string`.*
	
- *Example*
```go 
rows, err := db.Query("SELECT id, name FROM users")
if err != nil {
   log.Fatal(err)
}
defer rows.Close()

for rows.Next() {
   var id int
   var name string
   if err := rows.Scan(&id, &name); err != nil {
       log.Fatal(err)
   }
   fmt.Println(id, name)
}
```
- *In this example, we're querying a `users` table for `id` and `name` columns. For each row in the result set, we use `rows.Scan` to copy the data into the `id` and `name` variables. We then print out the values*. 
- *The arguments to row.Scan are `pointers` to the place you want to copy the data into.*
- *The # of arguments must be exactly the same as the # of columns returned by your statement.*
- `error.Is()`: Checks if an error is of a specific type of error. 
	- Takes 2 parameters: (error you want to check, the error type you want to compare it to)
	- Returns true if it matches the type we compare, false otherwise. 

# 4.8 Multiple-record SQL queries
- `rows.Err()` a method in Go's database/sql package and is assigned when  an error occurs during the iteration of rows. 
- It's crucial to include `defer rows.Close()` in our get function because if not then as long as the  resultset is open, it will maintain that database connection using resources and occupying that connection. 
# 4.9 Transactions and other details
## Managing null values 
- Go doesn't do a good job at managing SQL null values 
- *Example:* *we iterate through rows and one of the rows has a null title. the row.Scan() would return an error because go can't convert null to string. 
- **Solution:** The easy way is to set all your database columns to NOT NULL along with sensible DEFAULT values as necessary.
	- OR you could change the field that you're scanning into from a string to a sql.NullString type
## Transactions 
- `Exec()`,` Query()` and `QueryRow()` can use *any connection* from the *sql.DB pool*. 
- There's no guarantee something like two consecutive Exec() commands will use the same connection.
- This can sometimes be an issue
	- *Example: For instance, if you lock a table with MySQL’s LOCK TABLES command you must call UNLOCK TABLES on exactly the same connection to avoid a deadlock. *
- To guarantee the same connection you must wrap multiple statements in a transaction. 
- **Useful if you want to commit multiple SQL statements as a single atomic action.**
- 